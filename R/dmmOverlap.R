#' @importFrom stats dnbinom pnbinom qnbinom predict
.dmmOverlap <- function(model, tol=0.001) {

  # Naive mixture model
  if (all(c("mu1", "mu2", "theta1", "theta2") %in% names(model))) {
    mu1=model$mu1
    mu2=model$mu2
    theta1=model$theta1
    theta2=model$theta2
    
  # Regression mixture model
  } else if (all(c("fit1", "fit2") %in% names(model))) {
    mu1 <- predict(model$fit1, type="response")
    mu2 <- predict(model$fit2, type="response")
    theta1 <- model$fit1$theta
    theta2 <- model$fit2$theta
    f <- matrix(nrow=length(mu1), ncol=2)
    f[, 1] <- dnbinom(model$fit1$y, mu=mu1, size=theta1)
    f[, 2] <- dnbinom(model$fit2$y, mu=mu2, size=theta2)
    pi.f <- t(model$pi * t(f))
    posteriorProb <- pi.f / apply(pi.f, 1, sum)
    
    rna <- model$fit1$model$rna
    rna1 <- sum(rna * posteriorProb[, 1]) / sum(posteriorProb[, 1])
    rna2 <- sum(rna * posteriorProb[, 2]) / sum(posteriorProb[, 2])
    predData1 <- data.frame(hto=model$fit1$y, rna=rna1)
    predData2 <- data.frame(hto=model$fit2$y, rna=rna2)
    mu1 <- predict(model$fit1, newdata=predData1, type="response")[1]
    mu2 <- predict(model$fit2, newdata=predData2, type="response")[1]
    
  } else {
    stop("Parameter model must be a model generated by demuxmix().")
  }
  
  q1 <- qnbinom(1-tol, mu=mu1, size=theta1)
  q2 <- qnbinom(1-tol, mu=mu2, size=theta2)
  maxq <- max(q1, q2)
  area <- sum(pmin(dnbinom(0:maxq, mu=mu1, size=theta1), dnbinom(0:maxq, mu=mu2, size=theta2)))
  
  if (q1 <= q2) {  # density one has smaller tail at max(q1, q2)
    tail <- pnbinom(q=maxq, mu=mu1, size=theta1, lower.tail=FALSE)
  } else {         # density two has smaller tail at max(q1, q2)
    tail <- pnbinom(q=maxq, mu=mu2, size=theta2, lower.tail=FALSE)
  }
    
  return(area + tail)
}
  

setMethod("dmmOverlap", signature=c(model="list"),
  function (model, tol=0.001) {
    # Only one model given (for one hashtag)
    if (all(c("mu1", "mu2", "theta1", "theta2", "pi") %in% names(model)) | all(c("fit1", "fit2", "pi") %in% names(model))) {
      return(.dmmOverlap(model, tol=tol))
    
    # List of models for multiple hashtags
    } else {
      return(sapply(model, .dmmOverlap, tol=tol))
    }
  }
)